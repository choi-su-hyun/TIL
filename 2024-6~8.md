# 2024년 6월 ~ 8월  

## 6월 2일

### 작업  
 첫 렌더링 시 swiper 슬라이드의 특정 슬라이드로 이동시키기
 
### 문제점 발견 및 해결
슬라이더 내에 날짜 값과 현재 날짜 값을 비교해서 첫 렌더링 시 오늘 날짜의 슬라이드가 활성화되도록 변경이 필요했다. 하지만 react 컴포넌트에 대한 설명은 부족했고, 직접 swiper 객체를 만들어 구현하는 것이 일반적인 것으로 보였다.   

  - 해결   
  onSwiper 속성을 통해 setState를 넣어주어 현재 swiper 객체를 state에 저장하는 것으로 해결이 가능했다. 객체를 저장하고 useEffect 내에서 객체 메소드를 이용해 원하는 슬라이드로 이동시켰다.

### 배운점   
react 전용으로 제공하는 라이브러리의 객체를 사용해야한다면 state에 저장이 가능한지 찾아보자.

## 6월 4일

### 작업  
 검색 바 클릭 시 스크롤 이동 구현
 
### 문제점 발견 및 해결
focus가 되었을 때 스크롤을 시켜야하지만 검색바에 딱 걸리도록 구현하는 것이 아닌 검색바에서 살짝 더 위로 스크롤 되도록 구현해야했다.

  - 해결
    window.scrollTo()에 top 키 값을 보내주어 해당 인자 만큼 이동하도록 구현할 수 있었다.

### 배운점   
window.scrollTo()를 이용해 스크롤 이동이 가능하다.

## 6월 5일

### 작업  
 byte 제한하는 input 만들기
 
### 문제점 발견 및 해결
byte의 갯수를 계산했지만 특정 byte를 넘어가도 끝까지 작성되는 문제가 발생했다. slice를 통해 잘라냈지만 한 번만 적용될 뿐 다시 작성시   
byte가 쉽게 넘어갔다.

  - 해결
     특정 byte를 넘어서는 경우 slice를 한 번만 해서 문제였다. 한글은 3byte 영어는 1byte이기 때문에 이것에 맞춰 현재 작성중인 문자열의
    byte 수가 크다면 한 글자씩 제거해가는 방식으로 구현해야했다.

### 배운점   
- 특정 문자열의 byte를 계산해주는 정규식이 있다.
- slice(0,-1)을 통해 끝자리 제거한 문자열을 사용할 수 있다.

## 6월 6일

### 작업  
 인증번호 타이머 60초 남았을때/인증 실패했을 때 재전송할 수 있도록 변경하기
 
### 문제점 발견 및 해결
기존에 구현할 때 setinterval에 따라 타이머 숫자를 리렌더링하도록 하기 위해 interval 자체를 state에 넣고 그 안에서 60초보다 작을 경우에는 재전송이 가능하고 아닐 경우에는 재전송이 불가능하도록 구현했었다.   
하지만 이 상황에서 인증 실패 시 재전송을 가능하게 하려고하니 60초보다 적지 않은 이상 재전송을 할 수 없는 일이 벌어졌다.   

  - 해결
    조건문으로 60초 이상일 때 재전송 할 수 없도록 강제하는 것이 아니라 타이머가 시작할 때 한 번 재전송을 막고 타이머가 60초 아래일 때 재전송을 다시 켜주도록 변경하여 해결했다.
    또한 state에 setinterval을 직접넣게 되면서 복잡해진 코드를 useEffect를 이용해 setinterval로 time state가 변경되는 것을 감지해 해당 값을 리렌더링하도록 구현했다.

### 배운점   
- setInterval을 사용할 경우 리렌더링이 되기 위해서는 setInterval만 만들면되는 것이 아닌 상태 값에 따라 리렌더링이 될 수 있도록 해야한다. 하지만 state를 그냥 사용할 경우 전체페이지가 리렌더링되기 때문에 타이머가 이상하게 작동하게 된다. 이 때 useEffect를 이용해 타이머만 리렌더링 시키면 된다.
- setInterval을 통해 무언가의 상태를 변경해주어야한다면 interval 내에서 조작해주는 것이 아니라 밖에서 해당 값을 이용해 조건문을 작성해야한다. 그렇지 않으면 관련 상태나 변수를 자유롭게 컨트롤하기 어렵게 된다. 매 초마다 할당을 할 것이기 때문이다.

## 6월 7일

### 작업  
swiper loop 모드에서 원하는 슬라이드로 첫 렌더링시키기
 
### 문제점 발견 및 해결   
일부 슬라이드에서 한쪽에는 슬라이드가 없고 스와이프를 해야만 무한 스와이프로 변경되는 문제가 발생했다. loop를 위한 복제된 slide가 생성되기 전에 해당 위치로 보내지기 때문에 발생하는 것으로 보였다.

  - 해결
    slideTo를 통해 해당 슬라이드로 보내고 있었지만 렌더링 문제로인해 initialSlide를 통해 초기 값을 해당 슬라이더로 시작하도록 지정해주어 해결했다.
    또한 해당 슬라이드로 넘기는 값을 서버에서 받은 동적인 값을 사용하게 되면서 state를 이용하게 되었는데 state가 반영되지 않는 문제를 직면하게 되었고, 해당 state의 초기 값을 null로 주면서 null을 이용해 swiper를 렌더링 시키면서 값이 들어왔을 때만 swiper가 렌더링되도록 하여 해결했다.

### 배운점   
- swiper의 slideTo는 단순히 해당 슬라이드로 보내는 것이고, initialSlide는 해당 slide를 초기값으로 하여 swiper를 렌더링 시키는 것으로 loop를 기본적으로 사용하게 되는 프로젝트에서는 initialSlide가 더 좋은 선택지이다.
- 서버에서 받은 데이터를 state에 넣어서 적용시키고 싶지만 작동하지 않는다면 해당 state의 초기값을 null로 주면서 null이 아닌 경우에 렌더링시키면 서버에서 받은 값을 사용하도록 구현할 수 있다.

## 6월 9일

### 작업  
swiper의 슬라이드를 가장 긴 컨텐츠의 길이와 동일하게 유지시키기
 
### 문제점 발견 및 해결   
슬라이드의 내용물이 줄바꿈되면서 각 슬라이드의 길이가 달라지는 문제가 발생했다. swiper의 슬라이드가 flex 구조로 이루어져 있어 stretch를 이용해 해결하고자 했으나, stretch가 작동하지 않았다.

  - 해결
    swiper에 기본적으로 slide의 높이가 100%로 정해져있는데 align-items: stretch의 경우 자식의 높이가 정해져있으면 작동하지 않는 속성이였다. 그래서 해당 swiper의 슬라이드의 height를 auto로 높이를 지정하지 않아 해결했다.

### 배운점   
- flex의 align-items로 자식 요소를 stretch 시킬 수 있다. 하지만 height가 지정되어있는 경우 stretch는 작동하지 않는다.

## 6월 10일

### 작업  
swiper 관련 오류 해결하기
 
### 문제점 발견 및 해결   
swiper를 이용해 구현해둔 슬라이더가 loop 속성을 걸었지만 loop속성이 작동하지 않았다. 또한 스와이프 시 간헐적으로 어색하게 slide가 되었다.

  - 해결
    - 이전에 작동이 잘되는 것을 확인했었는데 현재는 작동이 안되는 것을 보고 그때와 지금의 차이점인 slide 개수가 영향을 미친다는 것을 알 수 있었다. swiper의 github에 이슈내역을 살펴보고 centeredSlide 속성에서 loop가 활성화되어있는 경우 동일한 에러가 발생하고 있다는 것을 알 수 있었다.
      또한 에러 해결이 명확하게 되지 않는 것도 확인되어 우선 swiper를 최신버전으로 업데이트하자 slide가 스와이프 시 간헐적으로 에러가 발생하던 문제는 해결이 되었다.
    - 슬라이드가 4개보다 적은 경우에 에러가 발생하는 것을 확인하여, 서버에서 오는 데이터가 4개 보다 적을 경우 동일한 슬라이드들을 한 번 더 return 시켜주어 해결했다.
    - 리스트가 하나만 있는 경우 slidePerView가 1이 되도록 조건문으로 처리했다. 

### 배운점   
- 사용하는 라이브러리에서 문제가 발생한 경우 해당 라이브러리의 github 이슈 페이지에서 찾아보고 현재 상황을 파악해야한다.
- 라이브러리를 쉽게 업데이트 및 다운그레이드가 가능하다.

## 6월 11일

### 작업  
checkbox 컴포넌트 제작
 
### 문제점 발견 및 해결   
checkbox 컴포넌트를 사용중 event를 받는 경우와 받지 못하는 경우가 있어, 이에 맞춰 type을 정해주고 onChange를 사용하고자 했다. 
type문제로 onChange: (event?: React.ChangeEvent<HTMLInputElement>) => void 를 통해 이벤트를 받거나 받지 않는다고 명시해주었었다. 그리고 이에 맞춰 onChange={() => 함수명}으로 type에 맞도록 작성해주었다.   
하지만 에러도 발생하지않고, 아무런 반응도 하지 않았다.

  - 해결
    onchange에 이벤트를 받으려면 onChange={함수명} 이렇게 넣어주거나, onChange={(event)=> 함수명(event)} 와 같이 전달 받은 이벤트가 함수로 무사히 이동할 수 있도록 해주어야 한다. 문제 상황처럼 작성하게 되면, 이벤트가 전달되지 못하고 함수는 아무런 이벤트도 받지 못한채 작동하지 않게되는 것이다.

### 배운점   
- 컴포넌트 내에서 함수의 인자를 넘겨주어야하는 경우 해당 함수까지 인자가 잘 전달 되고 있는지 확인하며 작성해야한다.

## 6월 12일

### 작업  
요소의 크기에 따라 ...처리
 
### 문제점 발견 및 해결   
기본적으로 나와있는 css ...처리 방법에는 text-overflow: ellipsis 등을 이용하는 방법이 있다. 하지만 width를 정해주지 않으면 작동하지 않는다.(100%는 작동하지 않음) 그러나 반응형 작업을 위해 width를 100%로 지정해주어야하는 상황이 주어졌었다.

  - 해결
    한 줄의 경우에는 위와 같이 text-overflow: ellipsis를 사용하지만 한 줄의 경우에도 -webkit-line-clamp: 1 를 이용하여 구현하게 되면 width가 100%라도 이에 맞춰 작동한다.
